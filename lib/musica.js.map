{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 227850296854245dcc17","webpack:///C:/Users/Admin/Documents/musica/src/index.js","webpack:///C:/Users/Admin/Documents/musica/src/array.js","webpack:///C:/Users/Admin/Documents/musica/~/tonal-array/build/tonal-array.js","webpack:///C:/Users/Admin/Documents/musica/~/tonal-pitch/build/tonal-pitch.js","webpack:///C:/Users/Admin/Documents/musica/~/tonal-pitch/~/note-parser/index.js","webpack:///C:/Users/Admin/Documents/musica/~/interval-notation/index.js","webpack:///C:/Users/Admin/Documents/musica/~/tonal-encoding/build/tonal-encoding.js","webpack:///C:/Users/Admin/Documents/musica/~/tonal-transpose/build/tonal-transpose.js","webpack:///C:/Users/Admin/Documents/musica/~/tonal-distance/build/tonal-distance.js","webpack:///C:/Users/Admin/Documents/musica/~/tonal-distance/~/tonal-pitch/build/tonal-pitch.js","webpack:///C:/Users/Admin/Documents/musica/~/note-parser/index.js","webpack:///C:/Users/Admin/Documents/musica/~/tonal-notation/build/tonal-notation.js","webpack:///C:/Users/Admin/Documents/musica/~/as-arr/index.js","webpack:///C:/Users/Admin/Documents/musica/src/settings.json"],"names":["select","settings","numbers","list","replicated_list","i"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;mBCtCQA,M;;;;AACR;;;;;;SACQC,Q;;;;;;;;;;;SCDQD,M,GAAAA,M;;AADhB;;AACO,UAASA,MAAT,CAAiBE,OAAjB,EAA0BC,IAA1B,EAAgC;AACtC,MAAIC,kBAAkBD,IAAtB;AACA,OAAK,IAAIE,IAAI,CAAb,EAAgBA,IAAI,EAApB,EAAwBA,GAAxB,EAA6B;AAC5BD,sBAAmB,MAAMD,IAAzB;AACA;AACD,SAAO,wBAAQD,OAAR,EAAiBE,eAAjB,CAAP;AACA,E;;;;;;ACPD;;AAEA,+CAA8C,cAAc;;AAE5D,gCAA+B,iFAAiF;;AAEhH;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,EAAE;AACb,aAAY,MAAM;AAClB;AACA;AACA,YAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB,YAAW,aAAa;AACxB,aAAY;AACZ;AACA;AACA,oCAAmC,yBAAyB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB;AACpB;;AAEA;AACA;AACA;AACA,YAAW,SAAS;AACpB,YAAW,aAAa;AACxB,aAAY;AACZ;AACA;AACA;AACA,oDAAmD;AACnD;AACA;;AAEA;AACA;AACA,YAAW,aAAa;AACxB,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB,YAAW,aAAa;AACxB,aAAY;AACZ;AACA;AACA;AACA,qBAAoB;AACpB;;AAEA;AACA;AACA,YAAW,aAAa;AACxB,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,aAAa;AACxB,aAAY,SAAS;AACrB;AACA,YAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,aAAa;AACxB,YAAW,aAAa;AACxB,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAAyB;AACzB;AACA,2BAA0B;;AAE1B;AACA;AACA;AACA;AACA,YAAW,iBAAiB;AAC5B;AACA;AACA,YAAW,aAAa;AACxB;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,YAAW,aAAa;AACxB,aAAY,MAAM;AAClB;AACA;AACA,YAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED,qBAAoB;;AAEpB;AACA;AACA;AACA,YAAW,QAAQ;AACnB,YAAW,aAAa;AACxB,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,QAAQ;AACnB,YAAW,aAAa;AACxB,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA,YAAW,aAAa;AACxB,YAAW,aAAa;AACxB,aAAY,MAAM;AAClB;AACA;AACA,YAAW,SAAS;AACpB;AACA;AACA;AACA;AACA,oDAAmD;AACnD;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB,aAAY,SAAS;AACrB;AACA,YAAW,SAAS;AACpB,+BAA8B,iBAAiB,cAAc;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yB;;;;;;AC9TA;;AAEA,+CAA8C,cAAc;;AAE5D;AACA;AACA;;AAEA;AACA;AACA,YAAW,QAAQ;AACnB,YAAW,QAAQ;AACnB,YAAW,QAAQ;AACnB,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,aAAY;AACZ;AACA,uBAAsB;AACtB;AACA;AACA,YAAW,QAAQ;AACnB,YAAW,QAAQ;AACnB,YAAW,QAAQ;AACnB,YAAW,QAAQ;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,MAAM;AACjB,aAAY,MAAM;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW;AACX,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,aAAY;AACZ;AACA,2BAA0B;AAC1B;AACA;AACA,YAAW;AACX,aAAY;AACZ;AACA,0BAAyB;AACzB;AACA;AACA,YAAW;AACX,aAAY;AACZ;AACA,oBAAmB;;AAEnB;AACA;AACA,YAAW;AACX,aAAY,QAAQ;AACpB;AACA,mBAAkB;;AAElB;AACA;AACA,YAAW;AACX,aAAY;AACZ;AACA,sBAAqB;AACrB;AACA;AACA,YAAW;AACX,aAAY;AACZ;AACA,qBAAoB;AACpB;AACA;AACA,YAAW;AACX,aAAY;AACZ;AACA,sBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,aAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA,YAAW,OAAO;AAClB,aAAY,MAAM;AAClB;AACA,0BAAyB;;AAEzB;AACA;AACA;AACA,YAAW;AACX,aAAY;AACZ;AACA,2BAA0B;AAC1B;AACA;AACA;AACA,YAAW;AACX,aAAY;AACZ;AACA,0BAAyB;AACzB;AACA;AACA;AACA,YAAW;AACX,aAAY;AACZ;AACA,uBAAsB;;AAEtB;AACA;AACA,YAAW;AACX,aAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW;AACX,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW;AACX,aAAY;AACZ;AACA,wBAAuB;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB,aAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB,aAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB,aAAY,SAAS;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2B;;;;;;AChRA;;AAEA;AACA,4BAA2B;AAC3B,qBAAoB;AACpB,qBAAoB;AACpB,qBAAoB;AACpB;AACA;AACA;;AAEA,4BAA2B,GAAG,GAAG,GAAG,GAAG,GAAG;AAC1C;AACA;AACA;AACA;AACA;AACA,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,QAAQ;AACnB;AACA;AACA,YAAW,MAAM;AACjB;AACA,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA,WAAU,gEAAgE;AAC1E;AACA;AACA;AACA;AACA;;AAEA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAkB;AAClB,mBAAkB;;AAElB;AACA;AACA,YAAW,OAAO;AAClB,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,eAAe;AAC1B,aAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;;;;;;;ACpMA;;AAEA;AACA,gCAA+B,IAAI,SAAS,IAAI;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,QAAQ;AACnB,aAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA,wBAAuB;AACvB,6BAA4B;;AAE5B;AACA;AACA;AACA,YAAW,QAAQ;AACnB,YAAW,QAAQ;AACnB;AACA,YAAW,QAAQ;AACnB;AACA,YAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,QAAQ;AACnB,YAAW,QAAQ;AACnB;AACA,YAAW,QAAQ;AACnB;AACA,YAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,eAAe;AAC1B;AACA,YAAW,OAAO;AAClB,aAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAwB;AACxB;AACA;AACA;AACA;AACA,YAAW,eAAe;AAC1B;AACA,YAAW,QAAQ;AACnB,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAkB;AAClB;AACA;;;;;;;ACpJA;;AAEA;;AAEA,qBAAoB;;AAEpB;AACA,KAAI;AACJ;AACA;AACA,qBAAoB;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yB;;;;;;AC1CA;;AAEA,+CAA8C,cAAc;;AAE5D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,aAAa;AACxB,YAAW,aAAa;AACxB,aAAY,aAAa;AACzB;AACA;AACA,oDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,aAAa;AACxB,YAAW,QAAQ;AACnB,aAAY,aAAa;AACzB;AACA,YAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6B;;;;;;AC9DA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,aAAa;AACxB,YAAW,aAAa;AACxB,aAAY,SAAS;AACrB;AACA,YAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,aAAa;AACxB,YAAW,aAAa;AACxB,aAAY,QAAQ;AACpB;AACA,YAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6B;;;;;;AC/DA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,QAAQ;AACnB,YAAW,QAAQ;AACnB,YAAW,QAAQ;AACnB,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,aAAY;AACZ;AACA,uBAAsB;AACtB;AACA;AACA,YAAW,QAAQ;AACnB,YAAW,QAAQ;AACnB,YAAW,QAAQ;AACnB,YAAW,QAAQ;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,MAAM;AACjB,aAAY,MAAM;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW;AACX,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,aAAY;AACZ;AACA,2BAA0B;AAC1B;AACA;AACA,YAAW;AACX,aAAY;AACZ;AACA,0BAAyB;AACzB;AACA;AACA,YAAW;AACX,aAAY;AACZ;AACA,oBAAmB;;AAEnB;AACA;AACA,YAAW;AACX,aAAY,QAAQ;AACpB;AACA,mBAAkB;;AAElB;AACA;AACA,YAAW;AACX,aAAY;AACZ;AACA,sBAAqB;AACrB;AACA;AACA,YAAW;AACX,aAAY;AACZ;AACA,qBAAoB;AACpB;AACA;AACA,YAAW;AACX,aAAY;AACZ;AACA,sBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,aAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA,YAAW,OAAO;AAClB,aAAY,MAAM;AAClB;AACA,0BAAyB;;AAEzB;AACA;AACA;AACA,YAAW;AACX,aAAY;AACZ;AACA,2BAA0B;AAC1B;AACA;AACA;AACA,YAAW;AACX,aAAY;AACZ;AACA,0BAAyB;AACzB;AACA;AACA;AACA,YAAW;AACX,aAAY;AACZ;AACA,uBAAsB;;AAEtB,sBAAqB;;AAErB;AACA;AACA,YAAW;AACX,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW;AACX,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW;AACX,aAAY;AACZ;AACA,wBAAuB;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB,aAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB,aAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB,aAAY,SAAS;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2B;;;;;;AChRA;;AAEA,4BAA2B,GAAG,GAAG,GAAG,GAAG,GAAG;AAC1C;AACA;AACA;AACA;AACA;AACA,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,QAAQ;AACnB;AACA,YAAW,MAAM;AACjB;AACA,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA,WAAU,gEAAgE;AAC1E;AACA;AACA;AACA;AACA;;AAEA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,QAAQ;AACnB,YAAW,MAAM;AACjB,aAAY,MAAM;AAClB;AACA;AACA;AACA;;AAEA,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;;;;;;;ACpJA;AACA;AACA;AACA,oDAAmD;AACnD,EAAC,2BAA2B;;AAE5B;AACA,uBAAsB;AACtB,uBAAsB;;AAEtB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAuB;;AAEvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,0BAAyB;AACzB,2BAA0B;;AAE1B;AACA;AACA;AACA;AACA;AACA;;AAEA,8BAA6B;;AAE7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAC,G;;;;;;AC/DD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,G","file":"musica.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"musica\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"musica\"] = factory();\n\telse\n\t\troot[\"musica\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 227850296854245dcc17\n **/","export {select} from './array'\r\nimport settings from 'json!./settings.json'\r\nexport {settings}\n\n\n/** WEBPACK FOOTER **\n ** c:/Users/Admin/Documents/musica/~/eslint-loader!C:/Users/Admin/Documents/musica/src/index.js\n **/","import {select as _select} from 'tonal-array'\r\nexport function select (numbers, list) {\r\n\tlet replicated_list = list\r\n\tfor (let i = 0; i < 10; i++) {\r\n\t\treplicated_list += ' ' + list\r\n\t}\r\n\treturn _select(numbers, replicated_list)\r\n}\n\n\n/** WEBPACK FOOTER **\n ** c:/Users/Admin/Documents/musica/~/eslint-loader!C:/Users/Admin/Documents/musica/src/array.js\n **/","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar tonalPitch = require('tonal-pitch');\nvar tonalTranspose = require('tonal-transpose');\nvar tonalDistance = require('tonal-distance');\nvar toArr = _interopDefault(require('as-arr'));\n\n// utility\nvar isArr = Array.isArray\nfunction hasVal (e) { return e || e === 0 }\n\n/**\n * Convert anything to array. Speifically, split string separated by spaces,\n * commas or bars. The arrays are passed without modifications and the rest of\n * the objects are wrapped.\n *\n * This function always returns an array (null or undefined values are converted\n * to empty arrays)\n *\n * Thanks to this function, the rest of the functions of this module accepts\n * any object (or more useful: strings) as an array parameter.\n *\n * @param {*} source - the thing to get an array from\n * @return {Array} the object as an array\n *\n * @example\n * import { asArr } from 'tonal-arrays'\n * asArr('C D E F G') // => ['C', 'D', 'E', 'F', 'G']\n * asArr('A, B, C')\n * asArr('A | B | C')\n */\nvar asArr = toArr.use(/\\s*\\|\\s*|\\s*,\\s*|\\s+/)\n\n/**\n * Return a new array with the elements mapped by a function.\n * Basically the same as the JavaScript standard `array.map` but with\n * two enhacements:\n *\n * - Arrays can be expressed as strings (see [asArr])\n * - This function can be partially applied. This is useful to create _mapped_\n * versions of single element functions. For an excellent introduction of\n * the adventages [read this](https://drboolean.gitbooks.io/mostly-adequate-guide/content/ch4.html)\n *\n * @param {Function} fn - the function\n * @param {Array|String} arr - the array to be mapped\n * @return {Array}\n * @example\n * var arr = require('tonal-arr')\n * var toUp = arr.map(function(e) { return e.toUpperCase() })\n * toUp('a b c') // => ['A', 'B', 'C']\n *\n * @example\n * var tonal = require('tonal')\n * tonal.map(tonal.transpose('M3'), 'C D E') // => ['E', 'F#', 'G#']\n */\nfunction map (fn, list) {\n  return arguments.length > 1 ? map(fn)(list)\n    : function (l) { return asArr(l).map(fn) }\n}\n\n/**\n * Compact map: map an array with a function and remove nulls.\n * Can be partially applied.\n * @param {Function} fn\n * @param {Array|String} list\n * @return {Array}\n * @see map\n */\nfunction cMap (fn, list) {\n  if (arguments.length === 1) return function (l) { return cMap(fn, list) }\n  return map(fn, list).filter(hasVal)\n}\n\n/**\n * Return a copy of the array with the null values removed\n * @param {String|Array} list\n * @return {Array}\n */\nfunction compact (arr) {\n  return asArr(arr).filter(hasVal)\n}\n\n/**\n * Filter an array with a function. Again, almost the same as JavaScript standard\n * filter function but:\n * - It accepts strings as arrays\n * - Can be partially applied\n *\n * @param {Function} fn\n * @param {String|Array} arr\n * @return {Array}\n */\nfunction filter (fn, list) {\n  return arguments.length > 1 ? filter(fn)(list)\n    : function (l) { return asArr(l).filter(fn) }\n}\n\n/**\n * Given a list of notes, return the distance from the first note to the rest.\n * @param {Array|String} notes - the list of notes\n * @return {Array} the intervals\n * @example\n * tonal.harmonics('C E g') // => ['1P', '3M', '5P']\n */\nfunction harmonics (list) {\n  var a = asArr(list)\n  return a.length ? a.map(tonalDistance.distance(a[0])).filter(hasVal) : a\n}\n\n/**\n * Given an array of intervals, create a function that harmonizes a\n * note with this intervals. Given a list of notes, return a function that\n * transpose the notes by an interval.\n *\n * @param {Array|String} ivls - the list of pitches\n * @return {Function} The harmonizer\n * @example\n * import { harmonizer } from 'tonal-arrays'\n * var maj7 = harmonizer('P1 M3 P5 M7')\n * maj7('C') // => ['C', 'E', 'G', 'B']\n * var C = harmonizer('C D E')\n * C('M3') // => ['E', 'G#', 'B']\n */\nfunction harmonizer (list) {\n  return function (tonic) {\n    return cMap(tonalTranspose.tr(tonic || 'P1'), list)\n  }\n}\n\n/**\n * Harmonizes a note with an array of intervals. It's a layer of sintatic\n * sugar over `harmonizer`.\n *\n * @function\n * @param {String|Array} ivl - the array of intervals\n * @param {String|Pitch} note - the note to be harmonized\n * @return {Array} the resulting notes\n * @example\n * var tonal = require('tonal')\n * tonal.harmonise('P1 M3 P5 M7', 'C') // => ['C', 'E', 'G', 'B']\n */\nvar harmonize = function (list, pitch) {\n  return arguments.length > 1 ? harmonizer(list)(pitch) : harmonizer(list)\n}\n\n// a custom height function that\n// - returns -Infinity for non-pitch objects\n// - assumes pitch classes has octave -10 (so are sorted before that notes)\nvar objHeight = function (p) {\n  if (!p) return -Infinity\n  var f = p[1] * 7\n  var o = typeof p[2] === 'number' ? p[2] : -Math.floor(f / 12) - 10\n  return f + o * 12\n}\n\n// ascending comparator\nfunction ascComp (a, b) { return objHeight(a) - objHeight(b) }\n// descending comparator\nfunction descComp (a, b) { return -ascComp(a, b) }\n\n/**\n * Sort an array or notes or intervals. It uses the JavaScript standard sort\n * function.\n *\n * @param {Boolean|Function} comp - the comparator. `true` means use an\n * ascending comparator, `false` a descending comparator, or you can pass a\n * custom comparator (that receives pitches in array notation)\n * @param {Array|String} arr - the array of notes or intervals\n * @example\n * import { sort } from 'tonal-arrays'\n * sort(true, 'D E C') // => ['C', 'D', 'E']\n * @example\n * var tonal = require('tonal')\n * tonal.sort(false, 'D E C') // => ['E', 'D', 'C']\n */\nfunction sort (comp, list) {\n  if (arguments.length > 1) return sort(comp)(list)\n  var fn = comp === true || comp === null ? ascComp\n    : comp === false ? descComp : comp\n  return listFn(function (arr) {\n    return arr.sort(fn)\n  })\n}\n\n/**\n * Randomizes the order of the specified array using the Fisherâ€“Yates shuffle.\n *\n * @function\n * @param {Array|String} arr - the array\n * @return {Array} the shuffled array\n *\n * @example\n * import { shuffle } from 'tonal-arrays'\n * @example\n * var tonal = require('tonal')\n * tonal.shuffle('C D E F')\n */\nvar shuffle = listFn(function (arr) {\n  var i, t\n  var m = arr.length\n  while (m) {\n    i = Math.random() * m-- | 0\n    t = arr[m]\n    arr[m] = arr[i]\n    arr[i] = t\n  }\n  return arr\n})\n\nfunction trOct (n) { return tonalTranspose.tr(tonalPitch.pitch(0, n, 1)) }\n\n/**\n * Rotates a list a number of times. It's completly agnostic about the\n * contents of the list.\n * @param {Integer} times - the number of rotations\n * @param {Array|String} list - the list to be rotated\n * @return {Array} the rotated array\n */\nfunction rotate (times, list) {\n  var arr = asArr(list)\n  var len = arr.length\n  var n = ((times % len) + len) % len\n  return arr.slice(n, len).concat(arr.slice(0, n))\n}\n\n/**\n * Rotates an ascending list of pitches n times keeping the ascending property.\n * This functions assumes the list is an ascending list of pitches, and\n * transposes the them to ensure they are ascending after rotation.\n * It can be used, for example, to invert chords.\n *\n * @param {Integer} times - the number of rotations\n * @param {Array|String} list - the list to be rotated\n * @return {Array} the rotated array\n */\nfunction rotateAsc (times, list) {\n  return listFn(function (arr) {\n    var len = arr.length\n    var n = ((times % len) + len) % len\n    var head = arr.slice(n, len)\n    var tail = arr.slice(0, n)\n    // See if the first note of tail is lower than the last of head\n    var s = tonalDistance.distInSemitones(head[len - n - 1], tail[0])\n    if (s < 0) {\n      var octs = Math.floor(s / 12)\n      if (times < 0) head = head.map(trOct(octs))\n      else tail = tail.map(trOct(-octs))\n    }\n    return head.concat(tail)\n  })(list)\n}\n\n/**\n * Select elements from a list.\n *\n * @param {String|Array} numbers - a __1-based__ index of the elements\n * @param {String|Array} list - the list of pitches\n * @return {Array} the selected elements (with nulls if not valid index)\n *\n * @example\n * import { select } from 'tonal-array'\n * select('1 3 5', 'C D E F G A B') // => ['C', 'E', 'G']\n * select('-1 0 1 2 3', 'C D') // => [ null, null, 'C', 'D', null ]\n */\nfunction select (nums, list) {\n  if (arguments.length === 1) return function (l) { return select(nums, l) }\n  var arr = asArr(list)\n  return asArr(nums).map(function (n) {\n    return arr[n - 1] || null\n  })\n}\n\n// #### Transform lists in array notation\nfunction asPitchStr (p) { return tonalPitch.strPitch(p) || p }\nfunction listToStr (v) {\n  return tonalPitch.isPitch(v) ? tonalPitch.strPitch(v)\n    : isArr(v) ? v.map(asPitchStr)\n    : v\n}\n\n/**\n * Decorates a function to so it's first parameter is an array of pitches in\n * array notation. Also, if the return value is a pitch or an array of pitches\n * in array notation, it convert backs to strings.\n *\n * @function\n * @param {Function} fn - the function to decorate\n * @return {Function} the decorated function\n * @example\n * import { listFn } from 'tonal-arrays'\n * var octUp = listFn((p) => { p[2] = p[2] + 1; return p[2] })\n * octUp('C2 D2 E2') // => ['C3', 'D3', 'E3']\n */\nfunction listFn (fn) {\n  return function (list) {\n    var arr = asArr(list).map(tonalPitch.asPitch)\n    var res = fn(arr)\n    return listToStr(res)\n  }\n}\n\nexports.asArr = asArr;\nexports.map = map;\nexports.cMap = cMap;\nexports.compact = compact;\nexports.filter = filter;\nexports.harmonics = harmonics;\nexports.harmonizer = harmonizer;\nexports.harmonize = harmonize;\nexports.sort = sort;\nexports.shuffle = shuffle;\nexports.rotate = rotate;\nexports.rotateAsc = rotateAsc;\nexports.select = select;\nexports.listFn = listFn;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** C:/Users/Admin/Documents/musica/~/tonal-array/build/tonal-array.js\n ** module id = 2\n ** module chunks = 0\n **/","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar noteParser = require('note-parser');\nvar intervalNotation = require('interval-notation');\nvar tonalEncoding = require('tonal-encoding');\n\n/**\n * Create a pitch\n * @param {Integer} fifths - the number of fifths from C or from P1\n * @param {Integer} focts - the number of encoded octaves\n * @param {Integer} dir - (Optional) Only required for intervals. Can be 1 or -1\n * @return {Pitch}\n */\nfunction pitch (fifths, focts, dir) {\n  return dir ? ['tnlp', [fifths, focts], dir] : ['tnlp', [fifths, focts]]\n}\n/**\n * Test if an object is a pitch\n * @param {Pitch}\n * @return {Boolean}\n */\nfunction isPitch (p) { return Array.isArray(p) && p[0] === 'tnlp' }\n/**\n * Encode a pitch\n * @param {Integer} step\n * @param {Integer} alt\n * @param {Integer} oct\n * @param {Integer} dir - (Optional)\n */\nfunction encode$1 (s, a, o, dir) {\n  return dir ? ['tnlp', tonalEncoding.encode(s, a, o), dir] : ['tnlp', tonalEncoding.encode(s, a, o)]\n}\n\n/**\n * Decode a pitch\n * @param {Pitch} the pitch\n * @return {Array} An array with [step, alt, oct]\n */\nfunction decode$1 (p) {\n  return tonalEncoding.decode.apply(null, p[1])\n}\n\n/**\n * Get pitch type\n * @param {Pitch}\n * @return {String} 'ivl' or 'note' or null if not a pitch\n */\nfunction pType (p) {\n  return !isPitch(p) ? null\n    : p[2] ? 'ivl' : 'note'\n}\n/**\n * Test if is a pitch note (with or without octave)\n * @param {Pitch}\n * @return {Boolean}\n */\nfunction isNotePitch (p) { return pType(p) === 'note' }\n/**\n * Test if is an interval\n * @param {Pitch}\n * @return {Boolean}\n */\nfunction isIvlPitch (p) { return pType(p) === 'ivl' }\n/**\n * Test if is a pitch class (a pitch note without octave)\n * @param {Pitch}\n * @return {Boolean}\n */\nfunction isPC (p) { return isPitch(p) && p[1].length === 1 }\n\n/**\n * Get direction of a pitch (even for notes)\n * @param {Pitch}\n * @return {Integer} 1 or -1\n */\nfunction dir (p) { return p[2] === -1 ? -1 : 1 }\n\n/**\n * Get encoded fifths from pitch.\n * @param {Pitch}\n * @return {Integer}\n */\nfunction fifths (p) { return p[2] === -1 ? -p[1][0] : p[1][0] }\n/**\n * Get encoded octaves from pitch.\n * @param {Pitch}\n * @return {Integer}\n */\nfunction focts (p) { return p[2] === -1 ? -p[1][1] : p[1][1] }\n/**\n * Get height of a pitch.\n * @param {Pitch}\n * @return {Integer}\n */\nfunction height (p) { return fifths(p) * 7 + focts(p) * 12 }\n\n/**\n * Get chroma of a pitch. The chroma is a number between 0 and 11 to represent\n * the position of a pitch inside an octave. Is the numeric equivlent of a\n * pitch class.\n *\n * @param {Pitch}\n * @return {Integer}\n */\nfunction chr (p) {\n  var f = fifths(p)\n  return 7 * f - 12 * Math.floor(f * 7 / 12)\n}\n\n// memoize parsers\nfunction memoize (fn) {\n  var cache = {}\n  return function (str) {\n    if (typeof str !== 'string') return null\n    return cache[str] || (cache[str] = fn(str))\n  }\n}\n\n/**\n * Parse a note\n * @function\n * @param {String} str\n * @return {Pitch} the pitch or null if not valid note string\n */\nvar parseNote = memoize(function (s) {\n  var p = noteParser.parse(s)\n  return p ? encode$1(p.step, p.alt, p.oct) : null\n})\n\n/**\n * Parse an interval\n * @function\n * @param {String} str\n * @return {Pitch} the pitch or null if not valid interval string\n */\nvar parseIvl = memoize(function (s) {\n  var p = intervalNotation.parse(s)\n  if (!p) return null\n  return p ? encode$1(p.simple - 1, p.alt, p.oct, p.dir) : null\n})\n\n/**\n * Parse a note or an interval\n * @param {String} str\n * @return {Pitch} the pitch or null if not valid pitch string\n */\nfunction parsePitch (s) { return parseNote(s) || parseIvl(s) }\n\n/**\n * Ensure the given object is a note pitch. If is a string, it will be\n * parsed. If not a note pitch or valid note string, it returns null.\n * @param {Pitch|String}\n * @return {Pitch}\n */\nfunction asNotePitch (p) { return isNotePitch(p) ? p : parseNote(p) }\n/**\n * Ensure the given object is a interval pitch. If is a string, it will be\n * parsed. If not a interval pitch or valid interval string, it returns null.\n * @param {Pitch|String}\n * @return {Pitch}\n */\nfunction asIvlPitch (p) { return isIvlPitch(p) ? p : parseIvl(p) }\n/**\n * Ensure the given object is a pitch. If is a string, it will be\n * parsed. If not a pitch or valid pitch string, it returns null.\n * @param {Pitch|String}\n * @return {Pitch}\n */\nfunction asPitch (p) { return isPitch(p) ? p : parsePitch(p) }\n\n/**\n * Convert a note pitch to string representation\n * @param {Pitch}\n * @return {String}\n */\nfunction strNote (p) {\n  if (!isNotePitch(p)) return null\n  return noteParser.build.apply(null, decode$1(p))\n}\n\n/**\n * Convert a interval pitch to string representation\n * @param {Pitch}\n * @return {String}\n */\nfunction strIvl (p) {\n  if (!isIvlPitch(p)) return null\n  // decode to [step, alt, oct]\n  var d = decode$1(p)\n  // d = [step, alt, oct]\n  var num = d[0] + 1 + 7 * d[2]\n  return p[2] * num + intervalNotation.altToQ(num, d[1])\n}\n\n/**\n * Convert a pitch to string representation (either notes or intervals)\n * @param {Pitch}\n * @return {String}\n */\nfunction strPitch (p) { return strNote(p) || strIvl(p) }\n\n// A function that creates a decorator\n// The returned function can _decorate_ other functions to parse and build\n// string representations\nfunction decorator (is, parse, str) {\n  return function (fn) {\n    return function (v) {\n      var i = is(v)\n      // if the value is in pitch notation no conversion\n      if (i) return fn(v)\n      // else parse the pitch\n      var p = parse(v)\n      // if parsed, apply function and back to string\n      return p ? str(fn(p)) : null\n    }\n  }\n}\n\n/**\n * Decorate a function to work internally with note pitches, even if the\n * parameters are provided as strings. Also it converts back the result\n * to string if a note pitch is returned.\n * @function\n * @param {Function} fn\n * @return {Function} the decorated function\n */\nvar noteFn = decorator(isNotePitch, parseNote, strNote)\n/**\n * Decorate a function to work internally with interval pitches, even if the\n * parameters are provided as strings. Also it converts back the result\n * to string if a interval pitch is returned.\n * @function\n * @param {Function} fn\n * @return {Function} the decorated function\n */\nvar ivlFn = decorator(isIvlPitch, parseIvl, strIvl)\n/**\n * Decorate a function to work internally with pitches, even if the\n * parameters are provided as strings. Also it converts back the result\n * to string if a pitch is returned.\n * @function\n * @param {Function} fn\n * @return {Function} the decorated function\n */\nvar pitchFn = decorator(isPitch, parsePitch, strPitch)\n\nexports.pitch = pitch;\nexports.isPitch = isPitch;\nexports.encode = encode$1;\nexports.decode = decode$1;\nexports.pType = pType;\nexports.isNotePitch = isNotePitch;\nexports.isIvlPitch = isIvlPitch;\nexports.isPC = isPC;\nexports.dir = dir;\nexports.fifths = fifths;\nexports.focts = focts;\nexports.height = height;\nexports.chr = chr;\nexports.parseNote = parseNote;\nexports.parseIvl = parseIvl;\nexports.parsePitch = parsePitch;\nexports.asNotePitch = asNotePitch;\nexports.asIvlPitch = asIvlPitch;\nexports.asPitch = asPitch;\nexports.strNote = strNote;\nexports.strIvl = strIvl;\nexports.strPitch = strPitch;\nexports.noteFn = noteFn;\nexports.ivlFn = ivlFn;\nexports.pitchFn = pitchFn;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** C:/Users/Admin/Documents/musica/~/tonal-pitch/build/tonal-pitch.js\n ** module id = 3\n ** module chunks = 0\n **/","'use strict'\n\n// util\nfunction fillStr (s, num) { return Array(num + 1).join(s) }\nfunction isNum (x) { return typeof x === 'number' }\nfunction isStr (x) { return typeof x === 'string' }\nfunction isDef (x) { return typeof x !== 'undefined' }\nfunction midiToFreq (midi, tuning) {\n  return Math.pow(2, (midi - 69) / 12) * (tuning || 440)\n}\n\nvar REGEX = /^([a-gA-G])(#{1,}|b{1,}|x{1,}|)(-?\\d*)\\s*(.*)\\s*$/\n/**\n * A regex for matching note strings in scientific notation.\n *\n * @name regex\n * @function\n * @return {RegExp} the regexp used to parse the note name\n *\n * The note string should have the form `letter[accidentals][octave][element]`\n * where:\n *\n * - letter: (Required) is a letter from A to G either upper or lower case\n * - accidentals: (Optional) can be one or more `b` (flats), `#` (sharps) or `x` (double sharps).\n * They can NOT be mixed.\n * - octave: (Optional) a positive or negative integer\n * - element: (Optional) additionally anything after the duration is considered to\n * be the element name (for example: 'C2 dorian')\n *\n * The executed regex contains (by array index):\n *\n * - 0: the complete string\n * - 1: the note letter\n * - 2: the optional accidentals\n * - 3: the optional octave\n * - 4: the rest of the string (trimmed)\n *\n * @example\n * var parser = require('note-parser')\n * parser.regex.exec('c#4')\n * // => ['c#4', 'c', '#', '4', '']\n * parser.regex.exec('c#4 major')\n * // => ['c#4major', 'c', '#', '4', 'major']\n * parser.regex().exec('CMaj7')\n * // => ['CMaj7', 'C', '', '', 'Maj7']\n */\nfunction regex () { return REGEX }\n\nvar SEMITONES = [0, 2, 4, 5, 7, 9, 11]\n/**\n * Parse a note name in scientific notation an return it's components,\n * and some numeric properties including midi number and frequency.\n *\n * @name parse\n * @function\n * @param {String} note - the note string to be parsed\n * @param {Boolean} isTonic - true the strings it's supposed to contain a note number\n * and some category (for example an scale: 'C# major'). It's false by default,\n * but when true, en extra tonicOf property is returned with the category ('major')\n * @param {Float} tunning - The frequency of A4 note to calculate frequencies.\n * By default it 440.\n * @return {Object} the parsed note name or null if not a valid note\n *\n * The parsed note name object will ALWAYS contains:\n * - letter: the uppercase letter of the note\n * - acc: the accidentals of the note (only sharps or flats)\n * - pc: the pitch class (letter + acc)\n * - step: s a numeric representation of the letter. It's an integer from 0 to 6\n * where 0 = C, 1 = D ... 6 = B\n * - alt: a numeric representation of the accidentals. 0 means no alteration,\n * positive numbers are for sharps and negative for flats\n * - chroma: a numeric representation of the pitch class. It's like midi for\n * pitch classes. 0 = C, 1 = C#, 2 = D ... 11 = B. Can be used to find enharmonics\n * since, for example, chroma of 'Cb' and 'B' are both 11\n *\n * If the note has octave, the parser object will contain:\n * - oct: the octave number (as integer)\n * - midi: the midi number\n * - freq: the frequency (using tuning parameter as base)\n *\n * If the parameter `isTonic` is set to true, the parsed object will contain:\n * - tonicOf: the rest of the string that follows note name (left and right trimmed)\n *\n * @example\n * var parse = require('note-parser').parse\n * parse('Cb4')\n * // => { letter: 'C', acc: 'b', pc: 'Cb', step: 0, alt: -1, chroma: -1,\n *         oct: 4, midi: 59, freq: 246.94165062806206 }\n * // if no octave, no midi, no freq\n * parse('fx')\n * // => { letter: 'F', acc: '##', pc: 'F##', step: 3, alt: 2, chroma: 7 })\n */\nfunction parse (str, isTonic, tuning) {\n  if (typeof str !== 'string') return null\n  var m = REGEX.exec(str)\n  if (!m || !isTonic && m[4]) return null\n\n  var p = { letter: m[1].toUpperCase(), acc: m[2].replace(/x/g, '##') }\n  p.pc = p.letter + p.acc\n  p.step = (p.letter.charCodeAt(0) + 3) % 7\n  p.alt = p.acc[0] === 'b' ? -p.acc.length : p.acc.length\n  var pos = SEMITONES[p.step] + p.alt\n  p.chroma = pos < 0 ? 12 + pos : pos % 12\n  if (m[3]) { // has octave\n    p.oct = +m[3]\n    p.midi = pos + 12 * (p.oct + 1)\n    p.freq = midiToFreq(p.midi, tuning)\n  }\n  if (isTonic) p.tonicOf = m[4]\n  return p\n}\n\nvar LETTERS = 'CDEFGAB'\nfunction acc (n) { return !isNum(n) ? '' : n < 0 ? fillStr('b', -n) : fillStr('#', n) }\nfunction oct (n) { return !isNum(n) ? '' : '' + n }\n\n/**\n * Create a string from a parsed object or `step, alteration, octave` parameters\n * @param {Object} obj - the parsed data object\n * @return {String} a note string or null if not valid parameters\n * @since 1.2\n * @example\n * parser.build(parser.parse('cb2')) // => 'Cb2'\n *\n * @example\n * // it accepts (step, alteration, octave) parameters:\n * parser.build(3) // => 'F'\n * parser.build(3, -1) // => 'Fb'\n * parser.build(3, -1, 4) // => 'Fb4'\n */\nfunction build (s, a, o) {\n  if (s === null || typeof s === 'undefined') return null\n  if (s.step) return build(s.step, s.alt, s.oct)\n  if (s < 0 || s > 6) return null\n  return LETTERS.charAt(s) + acc(a) + oct(o)\n}\n\n/**\n * Get midi of a note\n *\n * @name midi\n * @function\n * @param {String|Integer} note - the note name or midi number\n * @return {Integer} the midi number of the note or null if not a valid note\n * or the note does NOT contains octave\n * @example\n * var parser = require('note-parser')\n * parser.midi('A4') // => 69\n * parser.midi('A') // => null\n * @example\n * // midi numbers are bypassed (even as strings)\n * parser.midi(60) // => 60\n * parser.midi('60') // => 60\n */\nfunction midi (note) {\n  if ((isNum(note) || isStr(note)) && note >= 0 && note < 128) return +note\n  var p = parse(note)\n  return p && isDef(p.midi) ? p.midi : null\n}\n\n/**\n * Get freq of a note in hertzs (in a well tempered 440Hz A4)\n *\n * @name freq\n * @function\n * @param {String} note - the note name or note midi number\n * @param {String} tuning - (Optional) the A4 frequency (440 by default)\n * @return {Float} the freq of the number if hertzs or null if not valid note\n * @example\n * var parser = require('note-parser')\n * parser.freq('A4') // => 440\n * parser.freq('A') // => null\n * @example\n * // can change tuning (440 by default)\n * parser.freq('A4', 444) // => 444\n * parser.freq('A3', 444) // => 222\n * @example\n * // it accepts midi numbers (as numbers and as strings)\n * parser.freq(69) // => 440\n * parser.freq('69', 442) // => 442\n */\nfunction freq (note, tuning) {\n  var m = midi(note)\n  return m === null ? null : midiToFreq(m, tuning)\n}\n\nvar parser = { parse: parse, build: build, regex: regex, midi: midi, freq: freq }\n// add additional functions, one for each object property\nvar FNS = ['letter', 'acc', 'pc', 'step', 'alt', 'chroma', 'oct']\nFNS.forEach(function (name) {\n  parser[name] = function (src) {\n    var p = parse(src)\n    return p && isDef(p[name]) ? p[name] : null\n  }\n})\n\nmodule.exports = parser\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** C:/Users/Admin/Documents/musica/~/tonal-pitch/~/note-parser/index.js\n ** module id = 4\n ** module chunks = 0\n **/","'use strict'\n\n// shorthand tonal notation (with quality after number)\nvar IVL_TNL = '([-+]?)(\\\\d+)(d{1,4}|m|M|P|A{1,4})'\n// standard shorthand notation (with quality before number)\nvar IVL_STR = '(AA|A|P|M|m|d|dd)([-+]?)(\\\\d+)'\nvar COMPOSE = '(?:(' + IVL_TNL + ')|(' + IVL_STR + '))'\nvar IVL_REGEX = new RegExp('^' + COMPOSE + '$')\n\n/**\n * Parse a string with an interval in [shorthand notation](https://en.wikipedia.org/wiki/Interval_(music)#Shorthand_notation)\n * and returns an object with interval properties\n *\n * @param {String} str - the string with the interval\n * @return {Object} an object properties or null if not valid interval string\n * The returned object contains:\n * - `num`: the interval number\n * - `q`: the interval quality string (M is major, m is minor, P is perfect...)\n * - `simple`: the simplified number (from 1 to 7)\n * - `dir`: the interval direction (1 ascending, -1 descending)\n * - `type`: the interval type (P is perfectable, M is majorable)\n * - `alt`: the alteration, a numeric representation of the quality\n * - `oct`: the number of octaves the interval spans. 0 for simple intervals.\n * - `size`: the size of the interval in semitones\n * @example\n * var parse = require('interval-notation').parse\n * parse('M3')\n * // => { num: 3, q: 'M', dir: 1, simple: 3,\n * //      type: 'M', alt: 0, oct: 0, size: 4 }\n */\nfunction parse (str) {\n  if (typeof str !== 'string') return null\n  var m = IVL_REGEX.exec(str)\n  if (!m) return null\n  var i = { num: +(m[3] || m[8]), q: m[4] || m[6] }\n  i.dir = (m[2] || m[7]) === '-' ? -1 : 1\n  var step = (i.num - 1) % 7\n  i.simple = step + 1\n  i.type = TYPES[step]\n  i.alt = qToAlt(i.type, i.q)\n  i.oct = Math.floor((i.num - 1) / 7)\n  i.size = i.dir * (SIZES[step] + i.alt + 12 * i.oct)\n  return i\n}\nvar SIZES = [0, 2, 4, 5, 7, 9, 11]\n\nvar TYPES = 'PMMPPMM'\n/**\n * Get the type of interval. Can be perfectavle ('P') or majorable ('M')\n * @param {Integer} num - the interval number\n * @return {String} `P` if it's perfectable, `M` if it's majorable.\n */\nfunction type (num) {\n  return TYPES[(num - 1) % 7]\n}\n\nfunction dirStr (dir) { return dir === -1 ? '-' : '' }\nfunction num (simple, oct) { return simple + 7 * oct }\n\n/**\n * Build a shorthand interval notation string from properties.\n *\n * @param {Integer} simple - the interval simple number (from 1 to 7)\n * @param {Integer} alt - the quality expressed in numbers. 0 means perfect\n * or major, depending of the interval number.\n * @param {Integer} oct - the number of octaves the interval spans.\n * 0 por simple intervals. Positive number.\n * @param {Integer} dir - the interval direction: 1 ascending, -1 descending.\n * @example\n * var interval = require('interval-notation')\n * interval.shorthand(3, 0, 0, 1) // => 'M3'\n * interval.shorthand(3, -1, 0, -1) // => 'm-3'\n * interval.shorthand(3, 1, 1, 1) // => 'A10'\n */\nfunction shorthand (simple, alt, oct, dir) {\n  return altToQ(simple, alt) + dirStr(dir) + num(simple, oct)\n}\n/**\n * Build a special shorthand interval notation string from properties.\n * The special shorthand interval notation changes the order or the standard\n * shorthand notation so instead of 'M-3' it returns '-3M'.\n *\n * The standard shorthand notation has a string 'A4' (augmented four) that can't\n * be differenciate from 'A4' (the A note in 4th octave), so the purpose of this\n * notation is avoid collisions\n *\n * @param {Integer} simple - the interval simple number (from 1 to 7)\n * @param {Integer} alt - the quality expressed in numbers. 0 means perfect\n * or major, depending of the interval number.\n * @param {Integer} oct - the number of octaves the interval spans.\n * 0 por simple intervals. Positive number.\n * @param {Integer} dir - the interval direction: 1 ascending, -1 descending.\n * @example\n * var interval = require('interval-notation')\n * interval.build(3, 0, 0, 1) // => '3M'\n * interval.build(3, -1, 0, -1) // => '-3m'\n * interval.build(3, 1, 1, 1) // => '10A'\n */\nfunction build (simple, alt, oct, dir) {\n  return dirStr(dir) + num(simple, oct) + altToQ(simple, alt)\n}\n\n/**\n * Get an alteration number from an interval quality string.\n * It accepts the standard `dmMPA` but also sharps and flats.\n *\n * @param {Integer|String} num - the interval number or a string representing\n * the interval type ('P' or 'M')\n * @param {String} quality - the quality string\n * @return {Integer} the interval alteration\n * @example\n * qToAlt('M', 'm') // => -1 (for majorables, 'm' is -1)\n * qToAlt('P', 'A') // => 1 (for perfectables, 'A' means 1)\n * qToAlt('M', 'P') // => null (majorables can't be perfect)\n */\nfunction qToAlt (num, q) {\n  var t = typeof num === 'number' ? type(num) : num\n  if (q === 'M' && t === 'M') return 0\n  if (q === 'P' && t === 'P') return 0\n  if (q === 'm' && t === 'M') return -1\n  if (/^A+$/.test(q)) return q.length\n  if (/^d+$/.test(q)) return t === 'P' ? -q.length : -q.length - 1\n  return null\n}\n\nfunction fillStr(s, n) { return Array(Math.abs(n) + 1).join(s) }\n/**\n * Get interval quality from interval type and alteration\n *\n * @function\n * @param {Integer|String} num - the interval number of the the interval\n * type ('M' for majorables, 'P' for perfectables)\n * @param {Integer} alt - the interval alteration\n * @return {String} the quality string\n * @example\n * altToQ('M', 0) // => 'M'\n */\nfunction altToQ (num, alt) {\n  var t = typeof num === 'number' ? type(Math.abs(num)) : num\n  if (alt === 0) return t === 'M' ? 'M' : 'P'\n  else if (alt === -1 && t === 'M') return 'm'\n  else if (alt > 0) return fillStr('A', alt)\n  else if (alt < 0) return fillStr('d', t === 'P' ? alt : alt + 1)\n  else return null\n}\n\nmodule.exports = { parse: parse, type: type,\n  altToQ: altToQ, qToAlt: qToAlt,\n  build: build, shorthand: shorthand }\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** C:/Users/Admin/Documents/musica/~/interval-notation/index.js\n ** module id = 5\n ** module chunks = 0\n **/","'use strict';\n\n// Encoding pitches into fifhts/octave notation\n\nfunction isNum (n) { return typeof n === 'number' }\n\n// Map from letter step to number of fifths starting from 'C':\n// { C: 0, D: 2, E: 4, F: -1, G: 1, A: 3, B: 5 }\nvar FIFTHS = [0, 2, 4, -1, 1, 3, 5]\n// Given a number of fifths, return the octaves they span\nfunction fOcts (f) { return Math.floor(f * 7 / 12) }\n// Get the number of octaves it span each step\nvar FIFTH_OCTS = FIFTHS.map(fOcts)\n\nfunction encode (step, alt, oct) {\n  var f = FIFTHS[step] + 7 * alt\n  if (!isNum(oct)) return [f]\n  var o = oct - FIFTH_OCTS[step] - 4 * alt\n  return [f, o]\n}\n\n// Return the number of fifths as if it were unaltered\nfunction unaltered (f) {\n  var i = (f + 1) % 7\n  return i < 0 ? 7 + i : i\n}\n\n// We need to get the steps from fifths\n// Fifths for CDEFGAB are [ 0, 2, 4, -1, 1, 3, 5 ]\n// We add 1 to fifths to avoid negative numbers, so:\n// { 0: F, 1: C, 2: G, 3: D, 4: A, 5: E, 6: B}\nvar STEPS = [3, 0, 4, 1, 5, 2, 6]\n\nfunction decode (f, o) {\n  var step = STEPS[unaltered(f)]\n  var alt = Math.floor((f + 1) / 7)\n  if (!isNum(o)) return [step, alt]\n  var oct = o + 4 * alt + FIFTH_OCTS[step]\n  return [step, alt, oct]\n}\n\nexports.encode = encode;\nexports.decode = decode;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** C:/Users/Admin/Documents/musica/~/tonal-encoding/build/tonal-encoding.js\n ** module id = 6\n ** module chunks = 0\n **/","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar tonalPitch = require('tonal-pitch');\n\nfunction trBy (i, p) {\n  var t = tonalPitch.pType(p)\n  if (!t) return null\n  var f = tonalPitch.fifths(i) + tonalPitch.fifths(p)\n  if (tonalPitch.isPC(p)) return ['tnlp', [f]]\n  var o = tonalPitch.focts(i) + tonalPitch.focts(p)\n  if (t === 'note') return ['tnlp', [f, o]]\n  var d = tonalPitch.height(i) + tonalPitch.height(p) < 0 ? -1 : 1\n  return ['tnlp', [d * f, d * o], d]\n}\n\n/**\n * Transpose notes. Can be used to add intervals. At least one of the parameter\n * is expected to be an interval. If not, it returns null.\n *\n * @param {String|Pitch} a - a note or interval\n * @param {String|Pitch} b - a note or interavl\n * @return {String|Pitch} the transposed pitch or null if not valid parameters\n */\nfunction transpose (a, b) {\n  if (arguments.length === 1) return function (b) { return transpose(a, b) }\n  var pa = tonalPitch.asPitch(a)\n  var pb = tonalPitch.asPitch(b)\n  var r = tonalPitch.isIvlPitch(pa) ? trBy(pa, pb)\n    : tonalPitch.isIvlPitch(pb) ? trBy(pb, pa) : null\n  return a === pa && b === pb ? r : tonalPitch.strPitch(r)\n}\n\n/**\n * An alias for `transpose`\n * @function\n */\nvar tr = transpose\n\n/**\n * Transpose a tonic a number of perfect fifths. It can be partially applied.\n *\n * @function\n * @param {Pitch|String} tonic\n * @param {Integer} number - the number of times\n * @return {String|Pitch} the transposed note\n * @example\n * import { trFifths } from 'tonal-transpose'\n * [0, 1, 2, 3, 4].map(trFifths('C')) // => ['C', 'G', 'D', 'A', 'E']\n * // or using tonal\n * tonal.trFifths('G4', 1) // => 'D5'\n */\nfunction trFifths (t, n) {\n  if (arguments.length > 1) return trFifths(t)(n)\n  return function (n) {\n    return tr(t, tonalPitch.pitch(n, 0, 1))\n  }\n}\n\nexports.transpose = transpose;\nexports.tr = tr;\nexports.trFifths = trFifths;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** C:/Users/Admin/Documents/musica/~/tonal-transpose/build/tonal-transpose.js\n ** module id = 7\n ** module chunks = 0\n **/","'use strict';\n\nvar tonalPitch = require('tonal-pitch');\n\n// substract two pitches\nfunction substr (a, b) {\n  if (!a || !b || a[1].length !== b[1].length) return null\n  var f = tonalPitch.fifths(b) - tonalPitch.fifths(a)\n  if (tonalPitch.isPC(a)) return tonalPitch.pitch(f, -Math.floor(f * 7 / 12), 1)\n  var o = tonalPitch.focts(b) - tonalPitch.focts(a)\n  var d = tonalPitch.height(b) - tonalPitch.height(a) < 0 ? -1 : 1\n  return tonalPitch.pitch(d * f, d * o, d)\n}\n\n/**\n * Find distance between two pitches. Both pitches MUST be of the same type.\n * Distances between pitch classes always returns ascending intervals.\n * Distances between intervals substract one from the other.\n *\n * @param {Pitch|String} from - distance from\n * @param {Pitch|String} to - distance to\n * @return {Interval} the distance between pitches\n * @example\n * import { distance } from 'tonal-distance'\n * distance('C2', 'C3') // => 'P8'\n * distance('G', 'B') // => 'M3'\n * // or use tonal\n * var tonal = require('tonal')\n * tonal.distance('M2', 'P5') // => 'P4'\n */\nfunction distance (a, b) {\n  if (arguments.length === 1) return function (b) { return distance(a, b) }\n  var pa = tonalPitch.asPitch(a)\n  var pb = tonalPitch.asPitch(b)\n  var i = substr(pa, pb)\n  // if a and b are in array notation, no conversion back\n  return a === pa && b === pb ? i : tonalPitch.strIvl(i)\n}\n\n/**\n * Get the distance between two notes in semitones\n * @param {String|Pitch} from - first note\n * @param {String|Pitch} to - last note\n * @return {Integer} the distance in semitones or null if not valid notes\n * @example\n * import { distInSemitones } from 'tonal-distance'\n * distInSemitones('C3', 'A2') // => -3\n * // or use tonal\n * tonal.distInSemitones('C3', 'G3') // => 7\n */\nfunction distInSemitones (a, b) {\n  var i = substr(tonalPitch.asPitch(a), tonalPitch.asPitch(b))\n  return i ? tonalPitch.height(i) : null\n}\n\n/**\n * An alias for `distance`\n * @function\n */\nvar interval = distance\n\nexports.distance = distance;\nexports.distInSemitones = distInSemitones;\nexports.interval = interval;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** C:/Users/Admin/Documents/musica/~/tonal-distance/build/tonal-distance.js\n ** module id = 8\n ** module chunks = 0\n **/","'use strict';\n\nvar noteParser = require('note-parser');\nvar intervalNotation = require('interval-notation');\nvar tonalEncoding = require('tonal-encoding');\nvar tonalNotation = require('tonal-notation');\n\n/**\n * Create a pitch\n * @param {Integer} fifths - the number of fifths from C or from P1\n * @param {Integer} focts - the number of encoded octaves\n * @param {Integer} dir - (Optional) Only required for intervals. Can be 1 or -1\n * @return {Pitch}\n */\nfunction pitch (fifths, focts, dir) {\n  return dir ? ['tnlp', [fifths, focts], dir] : ['tnlp', [fifths, focts]]\n}\n/**\n * Test if an object is a pitch\n * @param {Pitch}\n * @return {Boolean}\n */\nfunction isPitch (p) { return tonalNotation.isArr(p) && p[0] === 'tnlp' }\n/**\n * Encode a pitch\n * @param {Integer} step\n * @param {Integer} alt\n * @param {Integer} oct\n * @param {Integer} dir - (Optional)\n */\nfunction encode$1 (s, a, o, dir) {\n  return dir ? ['tnlp', tonalEncoding.encode(s, a, o), dir] : ['tnlp', tonalEncoding.encode(s, a, o)]\n}\n\n/**\n * Decode a pitch\n * @param {Pitch} the pitch\n * @return {Array} An array with [step, alt, oct]\n */\nfunction decode$1 (p) {\n  return tonalEncoding.decode.apply(null, p[1])\n}\n\n/**\n * Get pitch type\n * @param {Pitch}\n * @return {String} 'ivl' or 'note' or null if not a pitch\n */\nfunction pType (p) {\n  return !isPitch(p) ? null\n    : p[2] ? 'ivl' : 'note'\n}\n/**\n * Test if is a pitch note (with or without octave)\n * @param {Pitch}\n * @return {Boolean}\n */\nfunction isNotePitch (p) { return pType(p) === 'note' }\n/**\n * Test if is an interval\n * @param {Pitch}\n * @return {Boolean}\n */\nfunction isIvlPitch (p) { return pType(p) === 'ivl' }\n/**\n * Test if is a pitch class (a pitch note without octave)\n * @param {Pitch}\n * @return {Boolean}\n */\nfunction isPC (p) { return isPitch(p) && p[1].length === 1 }\n\n/**\n * Get direction of a pitch (even for notes)\n * @param {Pitch}\n * @return {Integer} 1 or -1\n */\nfunction dir (p) { return p[2] === -1 ? -1 : 1 }\n\n/**\n * Get encoded fifths from pitch.\n * @param {Pitch}\n * @return {Integer}\n */\nfunction fifths (p) { return p[2] === -1 ? -p[1][0] : p[1][0] }\n/**\n * Get encoded octaves from pitch.\n * @param {Pitch}\n * @return {Integer}\n */\nfunction focts (p) { return p[2] === -1 ? -p[1][1] : p[1][1] }\n/**\n * Get height of a pitch.\n * @param {Pitch}\n * @return {Integer}\n */\nfunction height (p) { return fifths(p) * 7 + focts(p) * 12 }\n\n/**\n * Get chroma of a pitch. The chroma is a number between 0 and 11 to represent\n * the position of a pitch inside an octave. Is the numeric equivlent of a\n * pitch class.\n *\n * @param {Pitch}\n * @return {Integer}\n */\nfunction chr (p) {\n  var f = fifths(p)\n  return 7 * f - 12 * Math.floor(f * 7 / 12)\n}\n\n// memoize parsers\nfunction memoize (fn) {\n  var cache = {}\n  return function (str) {\n    if (!tonalNotation.isStr(str)) return null\n    return cache[str] || (cache[str] = fn(str))\n  }\n}\n\n/**\n * Parse a note\n * @function\n * @param {String} str\n * @return {Pitch} the pitch or null if not valid note string\n */\nvar parseNote = memoize(function (s) {\n  var p = noteParser.parse(s)\n  return p ? encode$1(p.step, p.alt, p.oct) : null\n})\n\n/**\n * Parse an interval\n * @function\n * @param {String} str\n * @return {Pitch} the pitch or null if not valid interval string\n */\nvar parseIvl = memoize(function (s) {\n  var p = intervalNotation.parse(s)\n  if (!p) return null\n  return p ? encode$1(p.simple - 1, p.alt, p.oct, p.dir) : null\n})\n\n/**\n * Parse a note or an interval\n * @param {String} str\n * @return {Pitch} the pitch or null if not valid pitch string\n */\nfunction parsePitch (s) { return parseNote(s) || parseIvl(s) }\n\n/**\n * Ensure the given object is a note pitch. If is a string, it will be\n * parsed. If not a note pitch or valid note string, it returns null.\n * @param {Pitch|String}\n * @return {Pitch}\n */\nfunction asNotePitch (p) { return isNotePitch(p) ? p : parseNote(p) }\n/**\n * Ensure the given object is a interval pitch. If is a string, it will be\n * parsed. If not a interval pitch or valid interval string, it returns null.\n * @param {Pitch|String}\n * @return {Pitch}\n */\nfunction asIvlPitch (p) { return isIvlPitch(p) ? p : parseIvl(p) }\n/**\n * Ensure the given object is a pitch. If is a string, it will be\n * parsed. If not a pitch or valid pitch string, it returns null.\n * @param {Pitch|String}\n * @return {Pitch}\n */\nfunction asPitch (p) { return isPitch(p) ? p : parsePitch(p) }\n\nfunction octStr (n) { return tonalNotation.isNum(n) ? n : '' }\n\n/**\n * Convert a note pitch to string representation\n * @param {Pitch}\n * @return {String}\n */\nfunction strNote (p) {\n  if (!isNotePitch(p)) return null\n  var d = decode$1(p)\n  // d = [step, alt, oct]\n  return tonalNotation.toLetter(d[0]) + tonalNotation.toAcc(d[1]) + octStr(d[2])\n}\n\n/**\n * Convert a interval pitch to string representation\n * @param {Pitch}\n * @return {String}\n */\nfunction strIvl (p) {\n  if (!isIvlPitch(p)) return null\n  // decode to [step, alt, oct]\n  var d = decode$1(p)\n  // d = [step, alt, oct]\n  var num = d[0] + 1 + 7 * d[2]\n  return p[2] * num + intervalNotation.altToQ(num, d[1])\n}\n\n/**\n * Convert a pitch to string representation (either notes or intervals)\n * @param {Pitch}\n * @return {String}\n */\nfunction strPitch (p) { return strNote(p) || strIvl(p) }\n\nfunction decorator (is, parse, str) {\n  return function (fn) {\n    return function (v) {\n      var i = is(v)\n      // if the value is in pitch notation no conversion\n      if (i) return fn(v)\n      // else parse the pitch\n      var p = parse(v)\n      // if parsed, apply function and back to string\n      return p ? str(fn(p)) : null\n    }\n  }\n}\n\n/**\n * Decorate a function to work internally with note pitches, even if the\n * parameters are provided as strings. Also it converts back the result\n * to string if a note pitch is returned.\n * @function\n * @param {Function} fn\n * @return {Function} the decorated function\n */\nvar noteFn = decorator(isNotePitch, parseNote, strNote)\n/**\n * Decorate a function to work internally with interval pitches, even if the\n * parameters are provided as strings. Also it converts back the result\n * to string if a interval pitch is returned.\n * @function\n * @param {Function} fn\n * @return {Function} the decorated function\n */\nvar ivlFn = decorator(isIvlPitch, parseIvl, strIvl)\n/**\n * Decorate a function to work internally with pitches, even if the\n * parameters are provided as strings. Also it converts back the result\n * to string if a pitch is returned.\n * @function\n * @param {Function} fn\n * @return {Function} the decorated function\n */\nvar pitchFn = decorator(isPitch, parsePitch, strPitch)\n\nexports.pitch = pitch;\nexports.isPitch = isPitch;\nexports.encode = encode$1;\nexports.decode = decode$1;\nexports.pType = pType;\nexports.isNotePitch = isNotePitch;\nexports.isIvlPitch = isIvlPitch;\nexports.isPC = isPC;\nexports.dir = dir;\nexports.fifths = fifths;\nexports.focts = focts;\nexports.height = height;\nexports.chr = chr;\nexports.parseNote = parseNote;\nexports.parseIvl = parseIvl;\nexports.parsePitch = parsePitch;\nexports.asNotePitch = asNotePitch;\nexports.asIvlPitch = asIvlPitch;\nexports.asPitch = asPitch;\nexports.strNote = strNote;\nexports.strIvl = strIvl;\nexports.strPitch = strPitch;\nexports.noteFn = noteFn;\nexports.ivlFn = ivlFn;\nexports.pitchFn = pitchFn;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** C:/Users/Admin/Documents/musica/~/tonal-distance/~/tonal-pitch/build/tonal-pitch.js\n ** module id = 9\n ** module chunks = 0\n **/","'use strict'\n\nvar REGEX = /^([a-gA-G])(#{1,}|b{1,}|x{1,}|)(-?\\d*)\\s*(.*)\\s*$/\n/**\n * A regex for matching note strings in scientific notation.\n *\n * @name regex\n * @function\n * @return {RegExp} the regexp used to parse the note name\n *\n * The note string should have the form `letter[accidentals][octave][element]`\n * where:\n *\n * - letter: (Required) is a letter from A to G either upper or lower case\n * - accidentals: (Optional) can be one or more `b` (flats), `#` (sharps) or `x` (double sharps).\n * They can NOT be mixed.\n * - octave: (Optional) a positive or negative integer\n * - element: (Optional) additionally anything after the duration is considered to\n * be the element name (for example: 'C2 dorian')\n *\n * The executed regex contains (by array index):\n *\n * - 0: the complete string\n * - 1: the note letter\n * - 2: the optional accidentals\n * - 3: the optional octave\n * - 4: the rest of the string (trimmed)\n *\n * @example\n * var parser = require('note-parser')\n * parser.regex.exec('c#4')\n * // => ['c#4', 'c', '#', '4', '']\n * parser.regex.exec('c#4 major')\n * // => ['c#4major', 'c', '#', '4', 'major']\n * parser.regex().exec('CMaj7')\n * // => ['CMaj7', 'C', '', '', 'Maj7']\n */\nfunction regex () { return REGEX }\n\nvar SEMITONES = [0, 2, 4, 5, 7, 9, 11]\n/**\n * Parse a note name in scientific notation an return it's components,\n * and some numeric properties including midi number and frequency.\n *\n * @name parse\n * @function\n * @param {String} note - the note string to be parsed\n * @param {Boolean} isTonic - true if the note is the tonic of something.\n * If true, en extra tonicOf property is returned. It's false by default.\n * @param {Float} tunning - The frequency of A4 note to calculate frequencies.\n * By default it 440.\n * @return {Object} the parsed note name or null if not a valid note\n *\n * The parsed note name object will ALWAYS contains:\n * - letter: the uppercase letter of the note\n * - acc: the accidentals of the note (only sharps or flats)\n * - pc: the pitch class (letter + acc)\n * - step: s a numeric representation of the letter. It's an integer from 0 to 6\n * where 0 = C, 1 = D ... 6 = B\n * - alt: a numeric representation of the accidentals. 0 means no alteration,\n * positive numbers are for sharps and negative for flats\n * - chroma: a numeric representation of the pitch class. It's like midi for\n * pitch classes. 0 = C, 1 = C#, 2 = D ... It can have negative values: -1 = Cb.\n * Can detect pitch class enhramonics.\n *\n * If the note has octave, the parser object will contain:\n * - oct: the octave number (as integer)\n * - midi: the midi number\n * - freq: the frequency (using tuning parameter as base)\n *\n * If the parameter `isTonic` is set to true, the parsed object will contain:\n * - tonicOf: the rest of the string that follows note name (left and right trimmed)\n *\n * @example\n * var parse = require('note-parser').parse\n * parse('Cb4')\n * // => { letter: 'C', acc: 'b', pc: 'Cb', step: 0, alt: -1, chroma: -1,\n *         oct: 4, midi: 59, freq: 246.94165062806206 }\n * // if no octave, no midi, no freq\n * parse('fx')\n * // => { letter: 'F', acc: '##', pc: 'F##', step: 3, alt: 2, chroma: 7 })\n */\nfunction parse (str, isTonic, tuning) {\n  if (typeof str !== 'string') return null\n  var m = REGEX.exec(str)\n  if (!m || !isTonic && m[4]) return null\n\n  var p = { letter: m[1].toUpperCase(), acc: m[2].replace(/x/g, '##') }\n  p.pc = p.letter + p.acc\n  p.step = (p.letter.charCodeAt(0) + 3) % 7\n  p.alt = p.acc[0] === 'b' ? -p.acc.length : p.acc.length\n  p.chroma = SEMITONES[p.step] + p.alt\n  if (m[3]) {\n    p.oct = +m[3]\n    p.midi = p.chroma + 12 * (p.oct + 1)\n    p.freq = midiToFreq(p.midi, tuning)\n  }\n  if (isTonic) p.tonicOf = m[4]\n  return p\n}\n\n/**\n * Given a midi number, return its frequency\n * @param {Integer} midi - midi note number\n * @param {Float} tuning - (Optional) the A4 tuning (440Hz by default)\n * @return {Float} frequency in hertzs\n */\nfunction midiToFreq (midi, tuning) {\n  return Math.pow(2, (midi - 69) / 12) * (tuning || 440)\n}\n\nvar parser = { parse: parse, regex: regex, midiToFreq: midiToFreq }\nvar FNS = ['letter', 'acc', 'pc', 'step', 'alt', 'chroma', 'oct', 'midi', 'freq']\nFNS.forEach(function (name) {\n  parser[name] = function (src) {\n    var p = parse(src)\n    return p && (typeof p[name] !== 'undefined') ? p[name] : null\n  }\n})\n\nmodule.exports = parser\n\n// extra API docs\n/**\n * Get midi of a note\n *\n * @name midi\n * @function\n * @param {String} note - the note name\n * @return {Integer} the midi number of the note or null if not a valid note\n * or the note does NOT contains octave\n * @example\n * var parser = require('note-parser')\n * parser.midi('A4') // => 69\n * parser.midi('A') // => null\n */\n/**\n * Get freq of a note in hertzs (in a well tempered 440Hz A4)\n *\n * @name freq\n * @function\n * @param {String} note - the note name\n * @return {Float} the freq of the number if hertzs or null if not valid note\n * or the note does NOT contains octave\n * @example\n * var parser = require('note-parser')\n * parser.freq('A4') // => 440\n * parser.freq('A') // => null\n */\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** C:/Users/Admin/Documents/musica/~/note-parser/index.js\n ** module id = 10\n ** module chunks = 0\n **/","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.notation = global.notation || {})));\n}(this, function (exports) { 'use strict';\n\n  var isArr = Array.isArray\n  function isNum (x) { return typeof x === 'number' }\n  function isStr (x) { return typeof x === 'string' }\n\n  // NOTE LETTERS\n  // ============\n\n  // Given a letter, return step\n  function toStep (l) {\n    var s = 'CDEFGAB'.indexOf(l.toUpperCase())\n    return s < 0 ? null : s\n  }\n\n  /**\n   * Is a valid step number\n   */\n  function isStep (d) { return !(d < 0 || d > 6) }\n\n  /**\n   * Given a step, return a letter\n   */\n  function toLetter (s) {\n    return isStep(s) ? 'CDEFGAB'.charAt(s) : null\n  }\n\n  // ACCIDENTALS\n  // ===========\n\n  function areFlats (s) { return /^b+$/.test(s) }\n  function areSharps (s) { return /^#+$/.test(s) }\n\n  function toAlt (s) {\n    return s === '' ? 0\n      : areFlats(s) ? -s.length\n      : areSharps(s) ? s.length\n      : null\n  }\n\n  function fillStr (s, num) { return Array(num + 1).join(s) }\n\n  function toAcc (n) {\n    return n === 0 ? ''\n      : n < 0 ? fillStr('b', -n)\n      : fillStr('#', n)\n  }\n\n  exports.isArr = isArr;\n  exports.isNum = isNum;\n  exports.isStr = isStr;\n  exports.toStep = toStep;\n  exports.isStep = isStep;\n  exports.toLetter = toLetter;\n  exports.areFlats = areFlats;\n  exports.areSharps = areSharps;\n  exports.toAlt = toAlt;\n  exports.toAcc = toAcc;\n\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** C:/Users/Admin/Documents/musica/~/tonal-notation/build/tonal-notation.js\n ** module id = 11\n ** module chunks = 0\n **/","'use strict'\n\n// Create a function that converts objects to arrays using the given string separator\nfunction use (sep) {\n  return function (o, s) {\n    var l = arguments.length\n    return l === 0 ? []\n      : Array.isArray(o) ? o\n      : typeof o === 'string' ? o.trim().split(l === 1 ? sep : s)\n      : [ o ]\n  }\n}\nvar asArr = use(/\\s+/)\nasArr.use = use\n\nmodule.exports = asArr\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** C:/Users/Admin/Documents/musica/~/as-arr/index.js\n ** module id = 12\n ** module chunks = 0\n **/","module.exports = {\n\t\"voice_ranges\": {\n\t\t\"soprano\": {\n\t\t\t\"low\": \"C4\",\n\t\t\t\"high\": \"E6\"\n\t\t},\n\t\t\"alto\": {\n\t\t\t\"low\": \"F2\",\n\t\t\t\"high\": \"D5\"\n\t\t},\n\t\t\"tenor\": {\n\t\t\t\"low\": \"B2\",\n\t\t\t\"high\": \"G4\"\n\t\t},\n\t\t\"bass\": {\n\t\t\t\"low\": \"E2\",\n\t\t\t\"high\": \"C4\"\n\t\t}\n\t}\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** C:/Users/Admin/Documents/musica/~/json-loader!C:/Users/Admin/Documents/musica/src/settings.json\n ** module id = 13\n ** module chunks = 0\n **/"],"sourceRoot":""}